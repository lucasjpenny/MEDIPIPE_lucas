---
title: "Aggregated_QC_Report"
output:
  html_document:
    toc: true
    toc_depth: 2
    toc_float: true
    theme: cerulean
params:
  readin: "aggr_qc_matrix.csv"
---

This report is generated by the [tcge-cfmedip-seq-pipeline](https://github.com/yzeng-lol/tcge-cfmedip-seq-pipeline)


```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = FALSE, warning = FALSE, message = FALSE)
## read in QC matrix for subsequent chunks
IN <- read.csv(params$readin)
##IN <- read.csv(readin)
```


```{r include=FALSE}
## loading packages without showing
library(dplyr)
library(ggplot2)
library(plotly)
library(gapminder)
#library(gplots)
library(knitr)
library(heatmaply)
```

## Selected QC metrics
* NOTE: The heatmap is drawn based on transformed Z scores. In general, **the darker, the worse**! Specifically:
  + raw_reads_depth, usable_reads_depth, saturation_maxEstCor and enrichment_GoGe: the darker, the lower
  + coverage_pctReadsWoCpG and coverage_pctCpGwoRead: the darker, the higher
  + fragment_size_mode: the darker, the further away from the mean mode

```{r, echo = FALSE, fig.width = 14, fig.height= 5}
## representative QC metrics
## raw_reads_depth, usable_reads_depth, fragment_size_mode, saturation_maxEstCor
## coverage_pctReadsWoCpG, coverage_pctCpGwoRead, enrichment_GoGe
qc_c <- as.matrix(select(IN, raw_reads_depth, usable_reads_depth,                                                   fragment_size_mode, saturation_maxEstCor,
                             coverage_pctReadsWoCpG, coverage_pctCpGwoRead,
                             enrichment_GoGe))
rownames(qc_c) <- IN$sample
qc_z <- scale(qc_c)
qc_sz <- qc_z   

## closer to 0 the better
## fragment size mode
qc_sz[, 3] <- abs(qc_sz[, 3])

## switch those metrics the higher, the better
qc_sz[, c(1, 2, 4, 7)] <- -qc_z[, c(1, 2, 4, 7)]
qc_sz[qc_sz < 0 ] <- 0
qc_sz[is.na(qc_sz)] <- 0


## heatmap.2
if(FALSE){
#library(gplots)
heatmap.2(t(qc_sz), col = hmcols,  scale = "none", trace = "none",
          lwid = c(2, 8),  margins = c(5, 15),
          density.info = "none",cexRow = 1, cexCol =0.5)
}

## interactive heatmap
{
mat <-t(qc_sz)
heatmaply(mat,
        dendrogram = "column",
        xlab = "Samples", ylab = "",
        main = "",
        scale = "none",
        grid_color = "white",
        grid_width = 0.00001,
        titleX = FALSE,
        hide_colorbar = TRUE,
        branches_lwd = 0.1,
        label_names = c("Feature:", "Sample:", "tansQC_Z:"),
        fontsize_row = 10, fontsize_col = 3,
        labCol = colnames(mat),
        labRow = rownames(mat),
        #heatmap_layers = theme(axis.line=element_blank()),
        ## costomize color
        scale_fill_gradient_fun = ggplot2::scale_fill_gradient2(
          low = "white",
          high = "red",
          #midpoint = 5,
          limits = c(0, max(max(mat)))
          )
)

}

```

## Reads QC metrics
### Summary statistics for raw, prefilter and aligned reads
* raw_reads_depth: number of raw reads or read pairs
* prefilter_reads: reads or read pairs after QC, adapter trimming and UMI barcode extraction (p.r.n)
* mapped_reads_pct: percentage of mapped reads or read pairs over the **prefileter_reads**
* usable_reads: reads or read pairs after removing the duplication. reads pairs require properly paired as well
* usable_reads_pct:  percentage of usable reads over **raw reads**

```{r echo = FALSE}
## display selected metrics
library(knitr)
sum <- summary(IN)[, 3:10]

sum_adj <- gsub(":", "",
           gsub("Min\\.", "",
           gsub("1st Qu\\.:", "",
           gsub("Median :", "",
           gsub("Mean", "",
           gsub("3rd Qu\\.:", "",
           gsub("Max\\.", "", sum)))))))

rownames(sum_adj) <- c("Min", "Q1", "Median", "Mean", "Q3", "Max")
ti <- paste("Number of samples: ", nrow(IN))

kable(sum_adj, caption = ti)
```

### Usable read depth per sample
```{r  echo = FALSE, fig.width = 13}
library(ggplot2)
library(plotly)
library(gapminder)

g <- ggplot(IN, aes(x = group, y = usable_reads_depth,
                      color = group, label = sample))
g <- g + geom_boxplot(outlier.shape = NA, outlier.colour = NA) +  geom_jitter()
g <- g + theme_bw() + theme(legend.position="none")
ggplotly(g, tooltip=c("y", "label"))
```

### Usable read depth percentages against raw read depth per sample
```{r echo = FALSE, fig.width = 13}
library(ggplot2)
library(plotly)
library(gapminder)

#IN <- read.table(params$readin, header = T)
raw_reads_depth_log10 <- log10(IN$raw_reads_depth)
g <- ggplot(IN, aes(x = raw_reads_depth_log10, y = usable_reads_depth_pct,
                    color = group, text = sample))
g <- g + geom_point() + theme_bw() + theme(legend.position="none")
g <- g + facet_grid(. ~ group)

ggplotly(g, tooltip=c("x", "y", "text"))
```

## Fragment QC metrics
### Fragment size Mode, Mean, Median
```{r echo = FALSE}
## display selected metrics
library(knitr)
sum <- summary(IN)[, 11:13]

sum_adj <- gsub(":", "",
           gsub("Min\\.", "",
           gsub("1st Qu\\.:", "",
           gsub("Median :", "",
           gsub("Mean", "",
           gsub("3rd Qu\\.:", "",
           gsub("Max\\.", "", sum)))))))

rownames(sum_adj) <- c("Min", "Q1", "Median", "Mean", "Q3", "Max")
ti <- paste("Number of samples: ", nrow(IN))

kable(sum_adj, caption = ti)
```

### Fragment size Mode
```{r  echo = FALSE, fig.width = 13}
library(ggplot2)
library(plotly)
library(gapminder)

g <- ggplot(IN, aes(x = group, y = fragment_size_mode,
                      color = group, label = sample))
g <- g + geom_boxplot(outlier.shape = NA, outlier.colour = NA) +  geom_jitter()
g <- g  + theme_bw() + theme(legend.position="none")
ggplotly(g, tooltip=c("y", "label"))
```

###  Fragment size ranges with >=80% properly paired reads
* Calculated by based on PICARD MEDIAN_INSERT_SIZE + WIDTH_OF_80_PERCENT/2
  + WIDTH_OF_80_PERCENT: The "width" of the bins, centered around the median, that encompass 80% of all read pairs.

```{r  echo = FALSE, fig.width = 13}
library(ggplot2)
library(plotly)
library(gapminder)

g <- ggplot(IN, aes(x = group, y = fragment_size_for_80pct_reads,
                      color = group, label = sample))
g <- g + geom_boxplot(outlier.shape = NA, outlier.colour = NA) +  geom_jitter()
g <- g  + theme_bw() + theme(legend.position="none")
ggplotly(g, tooltip=c("y", "label"))
```



## MEDIPS QC metrics
### Saturation and Coverage Metrics
```{r echo = FALSE}
## display selected metrics
library(knitr)
sum <- summary(IN)[, 15:19]

sum_adj <- gsub(":", "",
           gsub("Min\\.", "",
           gsub("1st Qu\\.:", "",
           gsub("Median :", "",
           gsub("Mean", "",
           gsub("3rd Qu\\.:", "",
           gsub("Max\\.", "", sum)))))))

rownames(sum_adj) <- c("Min", "Q1", "Median", "Mean", "Q3", "Max")
ti <- paste("Number of samples: ", nrow(IN))

kable(sum_adj, caption = ti)
```

### Coverage: percentage of usable reads without CpG, and CpGs without reads
```{r  echo = FALSE, fig.width = 13}
library(ggplot2)
library(plotly)
library(gapminder)

g <- ggplot(IN, aes(x = group, y = coverage_pctReadsWoCpG,
                      color = group, label = sample))
g <- g + geom_boxplot(outlier.shape = NA, outlier.colour = NA) +  geom_jitter()
g <- g  + theme_bw() + theme(legend.position="none")
ggplotly(g, tooltip=c("y", "label"))
```

```{r  echo = FALSE, fig.width = 13}
library(ggplot2)
library(plotly)
library(gapminder)

g <- ggplot(IN, aes(x = group, y = coverage_pctCpGwoRead,
                      color = group, label = sample))
g <- g + geom_boxplot(outlier.shape = NA, outlier.colour = NA) +  geom_jitter()
g <- g  + theme_bw() + theme(legend.position="none")
ggplotly(g, tooltip=c("y", "label"))
```



### Enrichment score per sample
```{r  echo = FALSE, fig.width = 13}
library(ggplot2)
library(plotly)
library(gapminder)

g <- ggplot(IN, aes(x = group, y = enrichment_GoGe,
                      color = group, label = sample))
g <- g + geom_boxplot(outlier.shape = NA, outlier.colour = NA) +  geom_jitter()
g <- g  + theme_bw() + theme(legend.position="none")  
ggplotly(g, tooltip=c("y", "label"))
```

```{r  echo = FALSE, fig.width = 13}
library(ggplot2)
library(plotly)
library(gapminder)

g <- ggplot(IN, aes(x = group, y = enrichment_relH,
                      color = group, label = sample))
g <- g + geom_boxplot(outlier.shape = NA, outlier.colour = NA) +  geom_jitter()
g <- g  + theme_bw() + theme(legend.position="none")
ggplotly(g, tooltip=c("y", "label"))
```
